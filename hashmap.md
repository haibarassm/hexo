# HashMap(看源码)
HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置。当程序执行 map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。
## hash 冲突
如果存在相同的hashcode，那么他们确定的索引位置就相同，这时判断他们的key是否相同，如果不相同，这时就是产生了hash冲突。  
Hash冲突后，那么HashMap的单个bucket里存储的不是一个 Entry，而是一个 Entry 链。
## 冲突处理
冲突处理主要分两种，一种是开放定址法，另一种是链地址法。HashMap的实现中采用的是链地址法。

开放定址法有两种处理方式，一种是线性探测另一种是平方探测。

线性探测：依次探测冲突位置的下一个位置。如，在哈希表的位置2处发生了冲突，则探测位置3处是否被使用了，若被使用了，则探测位置4……直至下一个被探测的位置为空（意味着还有位置可以插入元素---插入成功）或者探测了N-1（N为哈希表的长度）个元素又回到了原始的冲突位置处（意味着已经没有位置可供新元素插入了---插入失败）

因此，插入一个元素时，最坏情况下的时间复杂度为O（N），因为它有可能探测了N-1个元素！

平方探测：以平方大小来递增下一次待探测的位置。如，在哈希表位置2处发生了冲突，则探测 (1^2=1)位置3（2+1），若位置3被使用了，则探测（2^2=4） 位置6（2+4），若位置6被使用了，则探测（3^2=9）位置11（2+9=11）……平方探测法有一个特点：对于任何一个给定的素数N（假设哈希表的长度设置为素数），当计算( h(k) + i ^2 ) MOD N 时，随着 i 的增长，得到的结果是循环的。

因此，当平方探测重复探测了某一个位置时，说明探测失败即已经没有位置可供新元素插入了，尽管此时哈希表并没有满。

平方探测是跳着探测的，它忽略了一些位置，而这些位置可能是空的。即在哈希表仍未满的情况下，已经不能再插入新元素了

最坏情况下，平方探测需要检测 N/2个位置，因此插入一个元素的最坏时间复杂度为O（N）。

 

链地址法

在HashMap的实现中，采用的链地址法来解决冲突，它有一个桶的概念:对于Entry数组而言，数组的每个元素处存储的是链表，而不是直接的Value。在链表中的每个元素才是真正的<Key, Value>。而一个链表，就是一个桶！因此HashMap最多可以有Entry.length 个桶。